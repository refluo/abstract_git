---
share_link: https://share.note.sx/mquj4k0s#gpFBx05kUT+kVdL2cQHV9DbvY0kjPxjcHaa4Gd0653Q
share_updated: 2025-05-23T17:09:37+03:00
---
# > ==**Оглавление урока по CLI**==

```table-of-contents
```

# > ==**Командная строка (терминал/консоль)**==

Командная строка это просто чудо! Она появилась несколько лет назад из своего предшественника-телетайпа и остаётся одним из самых эффективных способов работы с операционной системой (ОС). Причины её преимущества по сравнению с графическим интерфейсом (типа рабочего стола, папочек в проводнике) сходны с преимуществами языка программирования над какой-то программой

- широкие возможности автоматизации
- способность почти как угодно взаимодействовать с ОС
- лёгкая передача рецептов (набора действий для достижения какой-то цели)
- меньшее потребление ресурсов

Хотя есть и минусы

- высокий порог входа
- большая сила – большая ответственность (об этом в других частях конспекта)
- не настолько fancy как графон, но это субъективно и быстро привыкаешь

### **Что такое эта ваша консоль?**

Консоль это по сути окно, где мы можем печатать команды, которые будут выполнены компьютером. Консоль широко используется для повседневной работы в системе (создание файликов/папочек, копирование/перенос информации, установка ПО, печатание в файлах, взаимодействие с сетью и так далее). То есть работа в ней аналогична работе на рабочем столе.

Как возможна работа в консоли? Просто для каждого обычного действия есть своя команда, например для копирования файла `data_maining.py` из папки `analytics` в домашнюю папку вместо щелчка правой кнопки по файлу, нажатия скопировать, перехода в домашнюю папку и нажатия вставить, мы просто пишем`cp analytics/data_maining.py ~`

И получаем такой же результат. Поначалу может показаться непривычным и неудобным – воспринимайте это как заклинания, а проблемы при использовании команд, как проблемы при изучении магии!

Вдобавок к набору команд (этих команд действительно много, они запоминаются постепенно), консоль предоставляет язык программирования bash. Он Тьюринг-полный, но своеобразный, и его используют в основном для продвинутой работы в консоли. В нашем курсе он не понадобится (для многих задач достаточно утилит, например git для контроля версий). Более того, далеко не на каждой работе нужно его продвинутое знание.

О том зачем вам вообще сдался этот терминал мы поговорим в следующей главе)

[Больше информации](https://ru.wikipedia.org/wiki/Bash)

[Обучательная статья по башу для тех, кому релевантно](https://habr.com/ru/post/47163/)

# > ==**Зачем нужна консоль**==

Она нужна из-за ряда причин:

1. Перечисленные в предыдущем шаге преимущества
2. Устройства серверов

Так мы плавно подошли к серверам

### **Сервер**

Сервер это просто особенно мощный компьютер, которым, как правило, пользуется больше одного человека одновременно. Типичные параметры сервера: несколько десятков-сотен ядер и сотни-тысячи гигабайт оперативной памяти.Понятное дело, сервера ставят не для того, чтобы поиграть в Cyberpunk2077 на максималках (для этого есть хорошие стационарные компьютеры): их назначение – computational-heavy задачи типа сборки генома, докинга (предсказание взаимодействия молекул), тренировки крупных моделей машинного обучения, прогоны симуляций, проверки математических гипотез, анализа астрофизических данных или любых других данных, которые больше оперативной памяти обычного компьютера. Помимо этого, сервера используется в любой команде, разрабатывающей один продукт, даже если каждому из них по отдельности не нужны большие вычислительные мощности.

Все суперкомпьютеры (или почти все) это сервера или кластеры (объединение компьютеров в одну вычислительную систему). Исходно они создавались для того, чтобы можно было шарить и эффективно распределять ресурсы. Поэтому там нет графического интерфейса (он потребляет ресурсы, которые можно потратить на вычисления).

Доминирующая часть ОС на серверах это UNIX, в частности Linux. Windows проиграла этот рынок из-за отсутствия ОС на сервера и качества своего софта, и сейчас пытается делать какие-то решения, но это ничтожная доля, которой можно пренебречь. К слову, на Windows есть терминал (cmd), но он "авторский" – на нём несовместимый с линуксом и гораздо менее богатый набор команд.

Таким образом, знание Linux (как преемника UNIX) весьма полезно, потому что именно он используется на серверах.

[Больше информации](https://ru.wikipedia.org/wiki/Linux)

# > ==**Как открыть консоль**==

### **Локально**

На линуксе/маке можно открыть терминал так: нажмите Ctrl + Alt + T, либо поищите среди своих программ Terminal/Konsole или что-то подобное.

На Windows есть урезанный аналог – введите cmd в поиске. Но рассмотренные нами команды не применяются в ней! Вам может помочь [cygwin](https://www.cygwin.com/)

### **На jupyterhub'е**

Нажмите New справа сверху и выберите там Terminal. Всё готово)

## **Внешний вид**

Представляет чёрное полотно, где отображаются ваши команды и аутпут в ответ на них.

Вы видите промпт, где слева идёт

`название пользователя@название сервера:нынешняя директория$`

После этого названия стоит курсор, где вы пишите команду, например

`jupyter-a.ilin@lab:~$ my_command`

[Обзор терминалов](https://habr.com/ru/company/itsumma/blog/463785/)

# > ==**Использованные на уроке базовые команды (и немного неиспользованных)**==

### **pwd**

Сокращение от print working directory. Делает то, чем назван) Не требует дополнительных указаний

```Plain
jupyter-a.ilin@lab:~$ pwd
/home/jupyter-a.ilin
```

### **ls**
  
Сокращение от list – выводит файлы и директории в указанной папке. Если не указать папку, то выведет всё в директории, где вы находитесь

```Plain
jupyter-a.ilin@lab:~$ ls
analytics  introduction_python  shared  test
```

```Plain
jupyter-a.ilin@lab:~$ ls analytics
data_maining.py  data_preprocessing  README.md
```

Также к большинству команд можно добавлять опции, меняющие их поведение. Например -lah выведет прямо всё содержимое папки c подробной информацией в колонку с human-readable размером файлов

```Plain
jupyter-a.ilin@lab:~$ ls -lah
total 72K
drwxrwx--- 12 jupyter-a.ilin jupyter-a.ilin 4.0K Jun 19 00:14 .
drwxrwxr-x 67 root           root           4.0K Jun 15 20:42 ..
drwxr-xr-x  4 jupyter-a.ilin jupyter-a.ilin 4.0K Jun 19 00:08 analytics
-rwxrwx---  1 jupyter-a.ilin jupyter-a.ilin   75 May 21 14:06 .bash_history
-rwxrwx---  1 jupyter-a.ilin jupyter-a.ilin  220 Apr  4  2018 .bash_logout
-rwxrwx---  1 jupyter-a.ilin jupyter-a.ilin 3.7K Apr  4  2018 .bashrc
drwxrwx---  6 jupyter-a.ilin jupyter-a.ilin 4.0K May 23 13:09 .cache
-rwxrwx---  1 jupyter-a.ilin jupyter-a.ilin    0 Jan 12 05:15 .cloud-locale-test.skip
drwxrwx---  3 jupyter-a.ilin jupyter-a.ilin 4.0K May 22 09:32 .config
-rw-r--r--  1 jupyter-a.ilin jupyter-a.ilin   53 Jun 18 19:08 .gitconfig
drwxrwx---  5 jupyter-a.ilin jupyter-a.ilin 4.0K May 15 16:12 introduction_python
drwxrwx---  2 jupyter-a.ilin jupyter-a.ilin 4.0K Jun 10 15:29 .ipynb_checkpoints
drwxrwx---  5 jupyter-a.ilin jupyter-a.ilin 4.0K May 15 15:59 .ipython
drwxrwx---  4 jupyter-a.ilin jupyter-a.ilin 4.0K Jun 13 02:23 .jupyter
drwxrwx---  3 jupyter-a.ilin jupyter-a.ilin 4.0K May 11 17:49 .local
-rwxrwx---  1 jupyter-a.ilin jupyter-a.ilin  807 Apr  4  2018 .profile
-rw-------  1 jupyter-a.ilin jupyter-a.ilin   16 Jun 18 18:53 .python_history
lrwxrwxrwx  1 jupyter-a.ilin jupyter-a.ilin   16 May  5 15:16 shared -> /srv/data/shared
drwx------  2 jupyter-a.ilin jupyter-a.ilin 4.0K Jun 18 18:42 .ssh
drwxrwx---  3 jupyter-a.ilin jupyter-a.ilin 4.0K Jun 18 13:39 test
```

### **cat**

Сокращение от concatenate – выдаёт содержимое файла (файлов)

```Plain
jupyter-a.ilin@lab:~$ cat .ssh/id_rsa.pub
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQDq8g0AQEhSHjKDrgjRE+gKZxPJp2p47QWuBRWUwvDzZahg1gGgQdcV4UW4KZ15Q/O5OW5uvyNw2ylOvpJw8Cfz1D3uryXM9hxPVDygTi/rYsxQhmSgPtQaog7QHINTR4ToWsWnchF7ZtizhdUXNNHSQF/D5QO9kflF1JAMVe4SIC102xrCwFzi+2opZMM731IFT/DpM92JIjh+jsEjMiQG9zaD6RQTqhW/S1kapJj3o2QAVFf2YV5xSOhGe7NgIsqN5mSTaTHampskSkX+ejPtznVLw8whDGSKhEv9P+y76ncjZnTEOsVVkNR2c9ic9B0OE/27Pt7i7ZCSo8SY/7PyP1LmnFArvwCq4K78RQEILD6uL0pD99+dNbwx7Cz9EfeKcmF25bL1vWe14OW0Kcf095xH2k8crgZr2LW9Ag0Cl5vFQ0qtzgCkZcntwXe23UBiIhdRUPxIipS90IAnkSYN65vWKv6+OmGNJ38blf0o0XvapXWtk2g+7hYjas7oz3XzaJKGIglZF2RtcZ0IEXgErvKN/CqrLexIkepWoOhnyzepBAKt0enwxx+bm3aSQQbiok0qsELSReVDi9f6xVCT0p6yaRxNq4HVor77YuQUHUYocoSMgWQWD0OETqIC2eK1RiHJ56MXtcWes1EHe+0x5JOm6fqJAQDcqA5mEMZwlw== jupyter-a.ilin@lab.karpov.courses
```

### **cd**

Означает change directory – позволяет перемещаться по папкам. Аналогичен щёлканью по папкам) После выполнения меняется папка, где вы находитесь

```Plain
jupyter-a.ilin@lab:~$ cd analytics/
jupyter-a.ilin@lab:~/analytics$
```

При использовании без аргумента перемещает в домашнюю директорию

### **mkdir**

Сокращение от make directory – то есть создает директории) Прямо как щёлкнуть правой кнопкой, создать папку, ввести название

```Plain
jupyter-a.ilin@lab:~$ mkdir my_new_dir
jupyter-a.ilin@lab:~$
```

Преимущество командной строки над графическим интерфейсом можно продемонстрировать в этом запуске - мы можем передать кучу папок сразу, и они все создадутся

```Plain
jupyter-a.ilin@lab:~$ mkdir my_new_dir1 my_new_dir2 my_new_dir3
jupyter-a.ilin@lab:~$ ls
analytics  introduction_python  my_new_dir  my_new_dir1  my_new_dir2  my_new_dir3  shared  test
```

### **rm**

Сокращение от remove – удаляет файлы или папки_Note: ПЕРВЫЕ ПОЛГОДА ПЕРЕД ПРИМЕНЕНИЕМ КАКОЙ-ТО КОМАНДЫ ПОГУГЛИТЕ ЧТО ОНА ДЕЛАЕТ_rm может быть очень опасна, будьте внимательны.

Без опций rm может удалять только файлы. Чтобы удалить папку добавьте `r` (означает recursive)

```Plain
jupyter-a.ilin@lab:~$ rm -r my_new_dir my_new_dir1 my_new_dir2 my_new_dir3
jupyter-a.ilin@lab:~$ ls
analytics  introduction_python  shared  test
```

Остерегайтесь выполнения команды `rm -rf /` (удалит всё без запроса подтверждения). А также остерегайтесь тех, кто вам это посоветует

# > ==**Асимметричное шифрование**==

Шифрование вообще говоря интересная тема, хотя и ненужная в нормальном обществе. Не будем углубляться в его применение и особенности, отметим лишь, что одно из использований – связь компьютеров между собой (в том числе с сервером). Асимметричное шифрование одно из самых мощных средств для шифрования, которое спасёт вас от взлома большинством злоумышленников.

_Note: если именно вас захотят взломать, то почти ничего не поможетNote2: если светить пароли или ключи, то тоже почти ничего не поможет, хотя тут справиться проще)_

Для генерации ключей используется утилита `ssh-keygen`. Ниже приведена генерация ключа (в местах, где просят ввести пароль, введите какой-нибудь пароль для более надёжного соединения)

```Plain
jupyter-a.ilin@lab:~$ ssh-keygen -t rsa -b 4096
Generating public/private rsa key pair.
Enter file in which to save the key (/home/jupyter-a.ilin/.ssh/id_rsa):
Created directory '/home/jupyter-a.ilin/.ssh'.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /home/jupyter-a.ilin/.ssh/id_rsa.
Your public key has been saved in /home/jupyter-a.ilin/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:UB6TkDdNHtKbHvKhWfWulOmsDc0gmuuDQoSDjSBxRLM jupyter-a.ilin@lab.karpov.courses
The key's randomart image is:
+---[RSA 4096]----+
|.+=   .o==o      |
|o. o  .o+=o..    |
|++E   .....+ .   |
|= o    .. *   .  |
| o      SB.o +   |
|  .    oo.o++ .  |
| .   .o   .+o.   |
|  . . ..   o+    |
|   . .o.  ...    |
+----[SHA256]-----+
```

Теперь в папке .ssh хранится пара ключей – публичный (id_rsa.pub) и приватный (id_rsa)

```Plain
jupyter-a.ilin@lab:~$ ls .ssh/
id_rsa  id_rsa.pub
```

Ни в коем случае не показывайте никому (в сети) свой приватный ключ. Публичный можно светить

Далее скопируйте содержимое публичного ключа, и введите его в гитлабе (подробнее в видео)

```Plain
jupyter-a.ilin@lab:~$ cat .ssh/id_rsa.pub
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQDq8g0AQEhSHjKDrgjRE+gKZxPJp2p47QWuBRWUwvDzZahg1gGgQdcV4UW4KZ15Q/O5OW5uvyNw2ylOvpJw8Cfz1D3uryXM9hxPVDygTi/rYsxQhmSgPtQaog7QHINTR4ToWsWnchF7ZtizhdUXNNHSQF/D5QO9kflF1JAMVe4SIC102xrCwFzi+2opZMM731IFT/DpM92JIjh+jsEjMiQG9zaD6RQTqhW/S1kapJj3o2QAVFf2YV5xSOhGe7NgIsqN5mSTaTHampskSkX+ejPtznVLw8whDGSKhEv9P+y76ncjZnTEOsVVkNR2c9ic9B0OE/27Pt7i7ZCSo8SY/7PyP1LmnFArvwCq4K78RQEILD6uL0pD99+dNbwx7Cz9EfeKcmF25bL1vWe14OW0Kcf095xH2k8crgZr2LW9Ag0Cl5vFQ0qtzgCkZcntwXe23UBiIhdRUPxIipS90IAnkSYN65vWKv6+OmGNJ38blf0o0XvapXWtk2g+7hYjas7oz3XzaJKGIglZF2RtcZ0IEXgErvKN/CqrLexIkepWoOhnyzepBAKt0enwxx+bm3aSQQbiok0qsELSReVDi9f6xVCT0p6yaRxNq4HVor77YuQUHUYocoSMgWQWD0OETqIC2eK1RiHJ56MXtcWes1EHe+0x5JOm6fqJAQDcqA5mEMZwlw== jupyter-a.ilin@lab.karpov.courses
```

[Инструкция по генерации ключей](https://www.ssh.com/ssh/keygen/)

[Ещё одна инструкция по генерации ключей](https://www.digitalocean.com/community/tutorials/how-to-set-up-ssh-keys-on-ubuntu-1604)

[Асимметричное шифрование на шоколадках](https://hackernoon.com/asymmetric-encryption-explained-using-chocolate-boxes-5a329ea6813e)

[Объяснение асимметричного шифрования](https://www.coursera.org/learn/internet-history/lecture/lY9Uw/security-public-private-key-secure-sockets)

# > ==**git**==

git – это система контроля версий и одноимённая команда. Она используется, чтобы удобно иметь историю разработки и удобно разработку в команде.

### **История разработки**

Помните как вы писали диплом? С большой вероятностью это происходило так:

1. вы приносите научнику новую версию диплома
2. он делает правки
3. вы переделываете диплом
4. повторяете пункт 1, пока всех всё не устроит

Отдельный привет длинным названиям файлов в ворде типа диплом_модифицированный_исправленный_переправленный =)

Может возникнуть ситуация, когда нужно вернуть то, что было пару версий назад и это трудно искать, или их может даже уже не быть(

С гитом такого не возникает – вся история модификаций ваших файлов отслеживается (если вы коммитете конечно, об этом позже). И вы можете достать содержимое отслеживаемых файлов разных версий, что положительно сказывается на сохранности информации)

### **Разработка в команде**

Помимо истории версий, гит позволяет разобраться с работой в одних файлах несколькими персонами и получить работающую готовую версию.

[Больше информации](https://git-scm.com/)

# > ==**Как работает гит**==

В простом варианте гит работает следующим образом:

- в репозитории вы делаете изменения
- сохраняете состояние репозитория с изменениями
- коммитите его (заливаете изменения как готовые)
- работаете дальше

Это позволяет наладить вам историю изменений, и возвращаться к предыдущим коммитам.

Создание веток позволяет независимо от других работать в репозитории, а потом их объединять:

- создаём ветку
- работаем в ней
- объединяем

В результате мы можем работать в общем репозитории и объединять нашу работу с вкладом других участников команды)

[Больше информации](https://githowto.com/ru)

[Небольшой курс по гиту](https://githowto.com/ru)

[Анимированные объяснения гита](https://learngitbranching.js.org/)

[gitbook](https://git-scm.com/book/en/v2)

# > ==**Команды git'а**==

### **git clone**

Клонирует репозиторий с сервера (сайта) к вам в папку

`git clone link`

После применения этой команды в 1-ый раз с нашим сервером вас спросят хотите ли вы с ним контактировать – напишите yes)

# > ==**Текстовый редактор vim**==

В консоли тоже можно редактировать файлы, и есть разные варианты, как это сделать. Один из самых олдскульных - с помощью редактора vim (вим). Его аналогами являются emacs и nano, которые считаются более дружелюбными к пользователю. Но у вима есть одно неоспоримое преимущество - вероятность, что он будет на машине (то есть будет установлен на системе, и будет доступен из терминала), стремится к 1. То есть, зная его хотя бы на самом базовом уровне, вы почти всегда сможете отредактировать что-то на компьютере или локальном сервере

### **Как открыть файл?**

Напишите

`vi filename`

это откроет файл filename в редакторе вим. Написано vi, а не vim, так как vi это просто более новая версия vim'а

### **Как создать новый файл?**

`vi new_filename`

откроет в виме пустой файл с именем new_filename, в котором будет сохранено то, что вы напишите

### **Редактирование файла**

Находясь в виме нажмите `i` - это переведёт вас в режим записи, это будет отображено надписью снизу INSERT. После этого можно писать текст, который вам нужен

### **Выход из режима записи**

Написав нужный текст, нажмите `Esc`, чтобы выйти из режима записи. Надпись INSERT снизу пропадёт

### **Сохранение файла**

Для сохранения изменений нажмите

`:w`

и `Enter`

При этом нужно находится в обычном режиме (без надписи INSERT снизу)

### **Выход из вима**

Находясь в обычном режиме, нажмите

`:q`

и `Enter`

### **Сохранение файла и выход из вима одновременно**

Находясь в обычном режиме, нажмите

`:wq`

и `Enter`

# > ==**Скрипты**==

Почти всё это время мы работали с вами только в юпитерских ноутбуках. Это стандарт в мире анализа данных, но исходно их не было (и ими пользуются не все айтишники, работающие с питоном). Исходно были питоновские скрипты - это просто текстовые файлы с расширением `py`. Пример скрипта simulacrum.py

```Plain
# This is a comment, next line is just print invocation
print('Hello there!')
```

В скриптах написан питоновский код (всё то, что мы писали в ячейках ноутбука) и их можно открывать для редактирования прямо в блокноте

### **Отличия питоновского скрипта от юпитерского ноутбука**

- можно писать только код (нет возможности вставлять картинки или markdown)
- удобно редактировать прямо в блокноте
- нет разделения на ячейки (будет выполняться весь скрипт целиком)

Для запуска питоновского скрипта необходимо вызвать питон и передать ему скрипт (нечто похожее происходит и в юпитере под капотом)

### **Питон как консольная команда**

В терминале мы можем запустить питоновский скрипт следующим образом

```Plain
python simulacrum.py
```

Это запустит выполнение скрипта simulacrum.py в питоне. По сути аналогично тому как мы выполняли ячейку в юпитер ноутбуке, только в ячейке всё содержимое файла simulacrum.py

Также мы можем запустить питон в интерактивном режиме

```Plain
python
```

Далее можно писать блоки кода, и после нажатия `Enter` питон сразу будет писать результат. Чтобы выйти из питона, напишите


и нажмите `Enter`

Либо нажмите `Ctrl + d`

# > ==**Оглавление урока по GIT**==

1. [Использованные команды git'а](https://www.notion.so/2656d91f21f3452abbb78c19716700b8?pvs=21)
2. [Базовое конфигурирование git'а](https://www.notion.so/2656d91f21f3452abbb78c19716700b8?pvs=21)
3. [Типичный workflow](https://www.notion.so/2656d91f21f3452abbb78c19716700b8?pvs=21)
4. [Начало работы и получение информации о репозитории](https://www.notion.so/2656d91f21f3452abbb78c19716700b8?pvs=21)
5. [Получение обновлённого репозитория](https://www.notion.so/2656d91f21f3452abbb78c19716700b8?pvs=21)
6. [Ветки](https://www.notion.so/2656d91f21f3452abbb78c19716700b8?pvs=21)
7. [Коммиты](https://www.notion.so/2656d91f21f3452abbb78c19716700b8?pvs=21)
8. [Изменение единого репозитория](https://www.notion.so/2656d91f21f3452abbb78c19716700b8?pvs=21)
9. [Merge conflict](https://www.notion.so/2656d91f21f3452abbb78c19716700b8?pvs=21)
10. [Больше ресурсов по гиту](https://www.notion.so/2656d91f21f3452abbb78c19716700b8?pvs=21)
11. [Добавление путей, где питон ищет модули для импорта](https://www.notion.so/2656d91f21f3452abbb78c19716700b8?pvs=21)

# > ==**Команды git'а**==

### **git clone**

Клонирует репозиторий с сервера (сайта) к вам в папку

`git clone link`

После применения этой команды в 1-ый раз с нашим сервером вас спросят хотите ли вы с ним контактировать – напишите yes)

[Документация](https://git-scm.com/docs/git-clone)

### **git status**

Выводит статус репозитория

[Документация](https://git-scm.com/docs/git-status)

### **git branch**

Выводит существующие ветки. Если написать после branch название, то вы создадите ветвь с таким названием

[Документация](https://git-scm.com/docs/git-branch)

### **git checkout**

Перемещает вас в указанную после checkout ветвь

[Документация](https://git-scm.com/docs/git-checkout)

### **git add**

Добавляет файл, указанный после add, в рассмотрение на коммит

[Документация](https://git-scm.com/docs/git-add)

### **git commit**

Коммитит добавленные git add файлы

`git commit -m "commit comment"`

В `"commit comment"` пишется комментарий к коммиту

[Документация](https://git-scm.com/docs/git-commit)

### **git push**

Закидывает закомиченный код в репозиторий. Сначала идёт место, куда вы пушите, а потом что вы пишите

`git push origin ilin/fix_akarpov_function`

Так мы запушили закомиченные у нас изменения из ветки `ilin/fix_akarpov_function` в `origin`

[Документация](https://git-scm.com/docs/git-push)

### **git pull**

Стягивает к вам последние изменения в общепринятом состоянии репозитория

`git pull`

[Документация](https://git-scm.com/docs/git-pull)

[Больше информации](https://git-scm.com/book/ru/v2/Appendix-C%3A-%D0%9A%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B-Git-%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5-%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B)

# > ==**Настройка информации о себе**==

Для создания коммитов нужно указать своё имя и почту, чтобы другие разработчики знали, кто выполняет изменения. Команды ниже конфигурируют гит под вас

```Plain
git config --global user.email "your@mail"
git config --global user.name "Your Name"
```

Так мы указали, что наша почта your@mail, а имя Your Name

[Документация](https://git-scm.com/docs/git-config)

[Краткий обзор работы с git](https://habr.com/ru/post/342116/)

[Ещё один обзор](https://habr.com/ru/post/174467/)

# > ==**Workflow при работе с git'ом**==

- в первый раз - склонировать репозиторий к себе, при желании посмотреть историю изменений
- обновить свою копию свежими изменениями с гитлаба
- создать ветку и внести изменения
- запушить изменения в гитлаб

Первый пункт делается один раз, когда вы получаете репозиторий, а пункты со второго по четвёртый представляют собой одну итерацию при работе

# > ==**Начало работы и получение информации о статусе**==

В начале нужно склонировать репозиторий, как мы делали в прошлом уроке. После этого репозиторий доступен на машине как папка

Допустим, нам нужно изменить какой-то скрипт или добавить новый. Для этого перейдём в папку, соответствующую репозиторию

```Plain
cd analytics
```

analytics - название папки интересующего репозитория

### **Информация о состоянии репозитория**

Команда `git status` позволяет узнать текущее состояние

```Plain
git status
```

и выдает следующую информацию

On branch master - говорит, что мы находимся в ветке master ( то есть основной ветке)Your branch is up to date with ‘origin/master’ - ветка обновлена с веткой masternothing to commit, working tree clean - никаких обновлений нет

[Документация](https://git-scm.com/docs/git-status)

`git log` - покажет всю историю коммитов

```Plain
git log
```

Выйти из него можно, нажав `q`

[Документация](https://git-scm.com/docs/git-log)

Коммиты - это чекпойнты (как сохранения в игре), на которые мы можем перейти, получив состояние репозитория, которое было на момент коммита (сохранения)

# > ==**Обновление репозитория**==

Первое, что нужно сделать - выполнить команду `git pull`

```Plain
git pull
```

Она стаскивает все последние состояния из репозитория и мы увидим все последние изменения в немAlready up to date - означает, что все последние обновления стянуты

[Документация](https://git-scm.com/docs/git-pull)

# > ==**Концепция веток**==

Ветки (ветви, брэнчи) - это инструмент для командной работы в гите. Создавая ветвь, мы получаем параллельную вселенную, где сначала всё так же, как в основной ветке master. Меняя код в одной ветке, состояние другой остаётся прежним, то есть ветки могут развиваться независимо друг от друга

При вызове команды

```Plain
git branch
```

отображается список доступных нам веток и подсвечивается та, в которой мы сейчас находимся

В данном случаеmaster - мы находимся в ветке master

Только что созданный репозиторий содержит только одну ветку - master, и она используется в качестве основной.

[Документация](https://git-scm.com/docs/git-branch)

### **Создание веток**

Если мы хотим внести какие-то изменения в репозитории - отредактировать код, добавить какие-то новые файлы - нужно создать новую ветку.По сути, создание ветки, – это способ внести изменения в проект и объединить их в итоге с остальным кодом. Ветка копирует все состояние из мастера.

Чтобы создать ветку надо написать всю ту же команду `git branch`, но дополнительно указать название ветки, которую нужно создать

```Plain
git branch akarpov/my_new_branch
```

Для перехода между ветками используется команда `git checkout`

```Plain
git checkout akarpov/my_new_branch
```

перенесёт нас в новую ветку

[Документация](https://git-scm.com/docs/git-checkout)

Для удаления ветки надо добавить опцию `d`. Если ветка не была запушена, но вы всё равно хотите её удалить, поставьте `D` вместо `d`

```Plain
git branch -d akarpov/my_new_branch
```

[Больше информации](https://git-scm.com/book/ru/v2/%D0%92%D0%B5%D1%82%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-Git-%D0%9E-%D0%B2%D0%B5%D1%82%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B8-%D0%B2-%D0%B4%D0%B2%D1%83%D1%85-%D1%81%D0%BB%D0%BE%D0%B2%D0%B0%D1%85)

# > ==**Внесение изменений (коммиты)**==

Предположим, что нам нужно отредактировать скрипт в репозитории. Прежде чем мы начнём редактировать, убедитесь, что создали новую ветку и перешли в неё

Редактировать можно или в юпитере, или через терминал (в виме). После внесения изменений и сохранения файла, необходимо запечатлеть изменения в виде коммита. Чтобы его создать нужно несколько шагов

### **Добавление файлов в коммит**

Прежде всего посмотрите в оутпут команды `git status`, и убедитесь, что она говорит о том, что произошло

```Plain
git status
```

Добавьте изменённый файл в будущий коммит

```Plain
git add file
```

Это добавит file в число изменений, которые будут "сохранены" в коммите. Чтобы добавить все изменения, можно написать

```Plain
git add .
```

Снова взгляните на

```Plain
git status
```

и убедитесь, что всё идёт по плану

Если что-то пошло не так, то воспользуйтесь командой

```Plain
git checkout .
```

которая откатит вас к состоянию последнего коммита.

### **Коммит**

Для самого коммита используется команда

```Plain
git commit  -m 'important concise comment' 
```

Это закоммитит все файлы, которые были добавлены с помощью add, с комментарием important concise comment

Снова взгляните на

```Plain
git status
```

А также посмотрите на

```Plain
git log
```

# > ==**Обновление единого репозитория**==

Теперь настало время поменять код в репозитории у всех разработчиков

Команда

```Plain
git push origin your_branch
```

запушит в репозиторий в гитлабе (origin) изменения, находящиеся в ветке your_branch. Также появится сообщение, что вы создали merge request, то есть запрос на слияние вашего кода с основным.Перейдите по ссылке из сообщения в браузере. В появившемся окне подтвердите merge request (submit merge request)

[Документация](https://git-scm.com/docs/git-push)

### **Зачем это надо**

Merge request (MR) позволяет предотвратить внесение некорректных изменений, которые сломают проект.

Рядом с именем ветки есть кнопка Merge request. При нажатии на нее открывается диалог позволяющий задать описание, добавить комментарий и выбрать кому из разработчиков будет отправлен MR. Также можно установить, что нужно чьё-либо одобрение для принятия merge request и слияния с веткой master.

После этого более скилловые разработчики могут посмотреть реквэст и вмёрджить его в master

Когда merge выполнен, можно переключиться на master и спуллить новые изменения

# > ==**Merge conflict**==

Что будет, если два разработчика одновременно будут вносить изменения в один файл? И при этом один из них сам вмёрджит изменения в masterПри попытке второго разработчика сделать git merge master возникнет конфликт

Будет сообщениеBoth modified - тот файл которые оба разработчика поменялиТут два вариант решения конфликта, принять версию другого разработчика или настоять на своей

Допустим, мы захотели настоять на своей версииВ файле удаляем все комментарии и оставляем свою версию, затем выполняем последовательно

```Plain
git add .
git commit -m ‘fix conflict with encoding’
git push origin akarpov/my_new_branch
```

И сабмиттим merge request

Если второй разработчик не согласен, то чтобы изменить файл надо повторить вышеперечисленные команды

Затем обновляем наш клонированный репозиторий

```Plain
git checkout master
```

[Краткий обзор работы с git](https://habr.com/ru/post/342116/)[Ещё один обзор](https://habr.com/ru/post/174467/)

# > ==**Ресурсы по гиту**==

[Описание возможностей git'а](https://git-scm.com/book/ru/v2)

[Мануал от Atlassian](https://www.atlassian.com/git)

[Интерактивный учебник](https://learngitbranching.js.org/)

[Пройти git за три часа](https://githowto.com/ru)

# > ==**Мутирование пути, где питон ищет модули**==

```Plain
import sys


sys.path.append('/path/to_your/folder')
```

Данный код добавит `/path/to_your/folder` в путь, где ищутся модули. После этого импорт вашего модуля, находящегося в этой папке, пройдёт успешно

То есть можно будет сделать импорт вашего файла, не находясь в той же папке, где он лежит

[Больше информации](https://stackoverflow.com/questions/31291608/effect-of-using-sys-path-insert0-path-and-sys-pathappend-when-loading-modul)